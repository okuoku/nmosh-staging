(library (nmosh text bogohtml)
         (export bogohtml-next)
         (import (nmosh))

(define (whitespace? c)
  (or
    (char=? #\space c)
    (char=? #\newline c)))

(define (get-tok p)
  (define (itr cur)
    (let ((a (lookahead-char p)))
      (cond
        ((eof-object? a) a) ; return an eof-object (ERROR)
        ((or (char=? a #\>) (whitespace? a))
         (list->string (reverse cur)))
        (else
          (itr (cons (get-char p) cur))))))
  (itr '()))

(define (skip-comment p)
  (define (itr a b c)
    (cond 
      ((and (char=? a b #\-) (char=? c #\>))
       #t)
      ((eof-object? c) c)
      (else
        (itr b c (get-char p)))))
  (itr #\\ #\\ #\\))

(define (skip-whitespace p)
  (let ((a (lookahead-char p)))
    (when (and (not (eof-object? a)) (whitespace? a))
      (get-char p)
      (skip-whitespace p))))

(define (get-attr-value p)
  (define (itr stop cur)
    (let ((a (lookahead-char p)))
      (cond
        ((eq? #f stop)
         (if (whitespace? a)
           (list->string (reverse cur))
           (itr stop (cons (get-char p) cur))))
        ((char=? stop a)
         (get-char p)
         (list->string (reverse cur)))
        (else
          (itr stop (cons (get-char p) cur))))))

  (skip-whitespace p)
  (let ((a (lookahead-char p)))
    (cond
      ((or (char=? a #\") (char=? a #\'))
       (itr (get-char p) '()))
      (else
        (itr #f '())))))

(define (get-attrs p)
  (define (finish l)
    (string->symbol (string-downcase (list->string (reverse l)))))
  (define (itr cur cur-name)
    (let ((a (lookahead-char p)))
      (cond
        ((eof-object? a) a); fatal error
        ((char=? a #\>)
         (if (pair? cur-name)
           (cons (cons (finish cur-name)
                       '()) ; no attr-value
                 cur)
           cur))
        ((char=? a #\=)
         (get-char p)
         (let ((v (get-attr-value p)))
           (itr (cons (cons (finish cur-name)
                            v)
                      cur)
                '())))
        ((whitespace? a)
         (skip-whitespace p)
         (itr 
           (if (pair? cur-name)
             (cons (cons (finish cur-name) '()) ; no attr-value
                    cur)
             cur)
           '()))
        (else
          (itr cur (cons (get-char p) cur-name))))))
  (skip-whitespace p)
  (itr '() '()))

(define (return-tag tagname p)
  (let* ((a (get-attrs p))
         (c (get-char p)))
    (when (and (not (eof-object? c))(char=? c #\/))
      (get-char p))
    (let* ((slash? (char=? #\/ (string-ref tagname 0)))
           (true-tagname (if slash?
                           (substring tagname 1 (string-length tagname)) ;; drop /
                           tagname)))
      (append
        (list (if slash? '*tag-end* '*tag-start*) (string->symbol (string-downcase true-tagname)))
        a))))

(define (get-tag p)
  (get-char p) ;; drop "<"
  (let ((t (get-tok p)))
    (cond
      ((eof-object? t) t) ; return an eof-object (ERROR)
      ((string=? "!--" t) ; comment
       (skip-comment p)
       (get-tag p))
      (else
        (return-tag t p)))))

(define (return-text p)
  (define (itr cur)
    (let ((a (lookahead-char p)))
      (cond
        ((or (eof-object? a) (char=? a #\<))
         (list '*text* (list->string (reverse cur))))
        (else
          (itr (cons (get-char p) cur))))))
  (itr '()))

;; events ::
;;  (*tag* SYM alist-attr) ; GENERATED BY POST-PROCESS
;;  (*tag-start* SYM alist-attr)
;;  (*tag-end* SYM)
;;  (*text* STRING)
;;  () ; end
(define (bogohtml-next p)
  (let ((a (lookahead-char p)))
    (cond
      ((eof-object? a) '())
      ((char=? a #\<) (get-tag p))
      (else (return-text p)))))


)
